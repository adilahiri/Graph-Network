alignment
seq_1 <- "ASEDLTI"
seq_2 <- "AEEDFGI"
data(PAM30)
score_mat <- "PAM30"
global_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "global", scoreOnly = FALSE)
local_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "local", scoreOnly = FALSE)
global_alignment
local_alignment
data_csv = read.csv("qc_spike.csv", header = TRUE)
pos<- vector()
count <-1
for (iter in 1:dim(data_csv)[1]){
if (sum(is.na(data_csv[iter,8:11])) >2 ){
pos[count] <- iter
count = count +1
}
else if (sum(is.na(data_csv[iter,12:15])) >2 ) {
pos[count] <- iter
count = count +1
}
else if (sum(is.na(data_csv[iter,16:19])) >2 ) {
pos[count] <- iter
count = count +1
}
}
data_csv_filtered <- data_csv[-pos,]
a<-lapply(data_csv, function(x) x[!if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2)||sum(is.na(data_csv[iter,16:19]) >2))]
a<-lapply(data_csv, function(x) x[!if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2)||sum(is.na(data_csv[iter,16:19]) >2))])
a<-lapply(data_csv, function(x) x[!(if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2)||sum(is.na(data_csv[iter,16:19]) >2)))])
a<-lapply(data_csv, function(x) x[!(if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2)||sum(is.na(data_csv[iter,16:19]) >2)))])
a<-lapply(data_csv, function(x) x[!(if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2) ||sum(is.na(data_csv[iter,16:19]) >2) ))])
a<-lapply(data_csv, function(x) x[if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2) ||sum(is.na(data_csv[iter,16:19]) >2) )])
a<-lapply(data_csv, function(x) {x[if(sum(is.na(data_csv[iter,8:11]) >2)||sum(is.na(data_csv[iter,12:15]) >2) ||sum(is.na(data_csv[iter,16:19]) >2) )]})
a<-lapply(data_csv,funtion(x) x[!length(which(is.na(x)))>2]
a<-lapply(data_csv,funtion(x) x[!length(which(is.na(x)))>2])
lapply(data_csv,funtion(x) x[!length(which(is.na(x)))>2])
a<-lapply(data_csv,'[',funtion(x) x[!length(which(is.na(x)))>2])
a<-lapply(data_csv,1,funtion(x) x[!length(which(is.na(x)))>2])
delete_row<-function(x){if (sum(is.na(x[1,8:11])) >2 ||sum(is.na(data_csv[iter,12:15])) >2 ||sum(is.na(data_csv[iter,16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,1,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(data_csv) data_csv[!delete_row(data_csv)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) {x[!delete_row(x)]})
a<-lapply(data_csv,funtion(x) {x[!delete_row(x)]})
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,FUN= funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,FUN = funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x))
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,funtion(x) x[!delete_row(x)])
a<-lapply(data_csv,function(x) x[!delete_row(x)])
a<-lapply(data_csv,function(x) x[!delete_row(x)])
a<-lapply(data_csv,1,function(x) x[!delete_row(x)])
a<-lapply(data_csv,1,function(x) x[!delete_row(x)])
a<-lapply(data_csv,function(data_csv) data_csv[!delete_row(data_csv)])
data_csv[1,8:11]
a<-lapply(data_csv,function(data_csv) data_csv[!delete_row(data_csv)])
a<-lapply(data_csv,1,function(x) x[!delete_row(x)])
a<-lapply(data_csv,function(x) x[!delete_row(x)])
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
dim(a)
delete_row<-function(x){if (sum(is.na(x[1,8:11])) >2 ||sum(is.na(data_csv[1,12:15])) >2 ||sum(is.na(data_csv[1,16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
data_csv[1,8:11]
a<-data_csv[1,:]
a<-data_csv[1,]
a
a[1,]
delete_row<-function(x){if (sum(is.na(x[1,8:11])) >2 ||sum(is.na(data_csv[1,12:15])) >2 ||sum(is.na(data_csv[1,16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
delete_row<-function(x){if (sum(is.na(x[,8:11])) >2 ||sum(is.na(data_csv[,12:15])) >2 ||sum(is.na(data_csv[,16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
a
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
a
data_csv
head(a)
data_csv
a<-lapply(data_csv,function(x) x[!delete_row(x)])
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)} }
delete_row<-function(x){if (sum(is.na(x[8:11])) >2 ||sum(is.na(data_csv[12:15])) >2 ||sum(is.na(data_csv[16:19])) >2){return(TRUE)}else{return(FALSE)} }
a<-lapply(data_csv,function(x) x[!delete_row(x)])
a
## Use seqinr to obtain the Genbank sequence for PSEN1.
library(seqinr)
choosebank("genbank")
PSEN1 <- query(listname = "PSEN1", query="SP=homo sapiens AND K=PSEN1")
## Use seqinr to obtain the Genbank sequence for PSEN1.
library(seqinr)
choosebank("genbank")
PSEN1 <- query(listname = "PSEN1", query="SP=homo sapiens AND K=PSEN1")
psen1_seqs <- getSequence(PSEN1)
psen1_names <- getName(PSEN1)
print(lapply(psen1_seqs,length))
length(psen1_seqs)
psen1_seqs <- getSequence(PSEN1)
psen1_names <- getName(PSEN1)
length(psen1_seqs)
print(psen1_names)
print(lapply(psen1_seqs,length))
print(unlist(lapply(psen1_seqs,length)))
write.fasta(psen1_seqs[1], psen1_names[1], file.out = "MyPSEN1.fasta")
sum(table(psen1_seqs[[3]])[2:3]) / length(psen1_seqs[[3]])
sum(table(psen1_seqs[[3]])[2:3]) / length(psen1_seqs[[3]])*100
library(Biostrings)
seq_1 <- "GTAG"
seq_2 <- "GAG"
score_mat <- nucleotideSubstitutionMatrix(match = 1, mismatch = -1, baseOnly = TRUE)
gap_open <- -2
gap_extend <- -2
alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat, gapOpening =
gap_open, gapExtension = gap_extend,type ="global",scoreOnly=FALSE)
alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat, gapOpening =
gap_open, gapExtension = gap_extend,type ="global",scoreOnly=FALSE)
allignment
alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat, gapOpening =
gap_open, gapExtension = gap_extend,type ="global",scoreOnly=FALSE)
alignment
seq_1 <- "ASEDLTI"
seq_2 <- "AEEDFGI"
data(PAM30)
score_mat <- "PAM30"
gap_open <- 0
gap_extend <- -2
global_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "global", scoreOnly = FALSE)
local_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "local", scoreOnly = FALSE)
global_alignment
local_alignment
gen_random_seqs <- function(sq, B) {
## Break input sequence into vector of characters.
sq <- strsplit(sq, "")[[1]]
n <- length(sq)
## Compute sample proportions of each observed letter.
sq_tbl <- table(sq)
sq_letters <- names(sq_tbl)
n_letters <- length(sq_letters)
pp <- numeric()
for(i in 1:length(sq_letters))
pp[i] <- sq_tbl[i] / n
## Generate B random sequences by sampling with replacement using a multinomial model.
sqs <- numeric(B)
for(i in 1:B)
sqs[i] <- paste(sample(sq_letters, n, rep = TRUE, prob = pp), collapse = "")
return(sqs)
}
## Function for computing a p-value for the alignment of two sequences. The sequence in
## the first argument should be shorter than or equal in length to that in the second
## argument.
align_p_val <- function(seq_1, seq_2, scoringMat, gapOpen, gapExtend, alignType, B) {
## Compute alignment score for original pair of sequences.
tt_0 <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = scoringMat,
gapOpening = gapOpen, gapExtension = gapExtend, type = "local", scoreOnly = TRUE)
## Generate B random versions of first sequence.
random_seqs <- gen_random_seqs(seq_1, B)
## For each random sequence, re-run the alignment and store the resulting score.
tt_B <- numeric(B)
for(i in 1:B)
tt_B[i] <- pairwiseAlignment(random_seqs[i], seq_2, substitutionMatrix = scoringMat,
gapOpening = gapOpen, gapExtension = gapExtend, type = alignType, scoreOnly = TRUE)
## Compute a p-value as the proportion of randomization-based alignment scores that are
## equal to or greater than our original observed score.
p_val <- mean(tt_B >= tt_0)
return(list("tt_0" = tt_0, "tt_B" = tt_B, "p_val" = p_val))
}
set.seed(101)
out <- align_p_val(seq_1, seq_2, score_mat, gap_open, gap_extend, "local", 1000)
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
polygon(c( dd[dd>=19], 19 ),  c(y[x>=19],0 ), col="red")
head dd
dd
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
polygon(c( dd[dd$x>=19], 19 ),  c(dd$y[dd$x>=19],0 ), col="red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
polygon(c(min(dd$x),19),c(min(y1),y1), density = 5, angle = 45,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
polygon(c(min(dd$x),19),c(min(dd$y),dd$y), density = 5, angle = 45,col="chocolate1")
length(dd$x)
length(dd$y)
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
polygon(c(min(dd$x),dd$x),c(min(dd$y),dd$y), density = 5, angle = 45,col="chocolate1")
pos_x <- which(dd$x <=19)
pos_x
dd$x[281]
dd$x[282]
pos_x <- max(which(dd$x <=19))
pos_x
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5, angle = 45,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5, angle = 45,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5, angle = 25,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5,,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5,col="chocolate1")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
#polygon(c(min(dd$x),dd$x[1:pos_x] ),c(min(dd$y),dd$y[1:pos_x]), density = 5,col="chocolate1")
out$p_val
# download dna sequences  HS -> homo sapiens MM-> MUS MUSCULUS
GENE_HS <- query(listname = "H1F0", query="SP=homo sapiens AND K=H1F0")
## Use seqinr to obtain the Genbank sequence for PSEN1.
library(seqinr)
choosebank("genbank")
PSEN1 <- query(listname = "PSEN1", query="SP=homo sapiens AND K=PSEN1")
# download dna sequences  HS -> homo sapiens MM-> MUS MUSCULUS
GENE_HS <- query(listname = "H1F0", query="SP=homo sapiens AND K=H1F0")
GENE_MM <- query(listname = "H1F0", query="SP=mus musculus AND K=H1F0")
# Get the sequences
HS_H1F0_seqs <- getSequence(GENE_HS) # human sequence
MM_H1F0_seqs <- getSequence(GENE_MM) # mouse sequence
# Sequences
HS_Seq <- HS_H1F0_seqs[1]
MM_Seq <- MM_H1F0_seqs[1]
Miss_Match <- 100*length(which(HS_Seq[[1]]!=MM_Seq[[1]]))/length(MM_Seq[[1]]) # % Difference in Bases
Miss_Match <- 100*length(which(HS_Seq[[1]]!=MM_Seq[[1]]))/length(MM_Seq[[1]]) # % Difference in Bases
Miss_Match
Miss_Match <- 100*length(which(HS_Seq[[1]]!=MM_Seq[[1]]))/length(MM_Seq[[1]]) # % Difference in Bases
Miss_Match
dotPlot(HS_Seq[[1]][1:585], MM_Seq[[1]][1:585], col=c("white", "red"), xlab = "HUMAN", ylab = "MOUSE",main="DOT PLOT OF MOUSE VS HUMAN MAX GENE")
HS_Seq<-toupper(HS_Seq[[1]])
MM_Seq<-toupper(MM_Seq[[1]])
HS_Seq<-paste(HS_Seq,collapse="")
MM_Seq<-paste(MM_Seq,collapse="")
out <- align_p_val(HS_Seq, MM_Seq, score_mat, gap_open, gap_extend,"global", B = 1000)
out$p_val
library(muscle)
GENE_BT <- query(listname = "H1F0", query="SP=bos taurus AND K=H1F0")
BT_H1F0_seqs <- getSequence(GENE_BT) # cow sequence
BT_Seq <- BT_H1F0_seqs[1]
BT_Seq<-toupper(BT_Seq[[1]])
BT_Seq<-paste(BT_Seq,collapse="")
require(Biostrings)
String_Object <-  DNAStringSet(c(BT_Seq,HS_Seq,MM_Seq))
String_align <- muscle(String_Object)
detail(String_align)
dim(String_align)
String_align
String_align[1,1:50]
String_align[1,1:50]
String_align
typeof(String_align)
String_align[1]
String_align[[1]]
String_align@rowmask
String_align@group
String_align@ranges
String_align@unmasked
String_align@unmasked[1]
String_align@unmasked[1][1:50]
String_align@unmasked[1.1:50]
String_align@unmasked[1,1:50]
String_align@unmasked[1]
a<-String_align@unmasked[1]
a
lm(a)
String_align@unmasked[2]
String_align@unmasked[2][1:50]
String_align@unmasked[[1]]
String_align@unmasked[[1]][1:50]
String_align@unmasked[[2]][1:50]
String_align@unmasked[[3]][1:50]
String_align@unmasked[[1]][1:50]
data_csv = read.csv("qc_spike.csv", header = TRUE)
pos<- vector()
count <-1
for (iter in 1:dim(data_csv)[1]){
if (sum(is.na(data_csv[iter,8:11])) >2 ){
pos[count] <- iter
count = count +1
}
else if (sum(is.na(data_csv[iter,12:15])) >2 ) {
pos[count] <- iter
count = count +1
}
else if (sum(is.na(data_csv[iter,16:19])) >2 ) {
pos[count] <- iter
count = count +1
}
}
data_csv_filtered <- data_csv[-pos,]
dim(data_csv_filtered)[1]
length(which(data_csv_filtered[,7]==1))
length(which(data_csv_filtered[,7]==0))
data_mat<-as.matrix(data_csv_filtered[,8:19])
boxplot(data_mat,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of Filtered Data")
#boxplot.matrix(data_mat)
pos_salmonella <- which(data_csv_filtered[,7]==0)
data_mat_salmonella<-data_mat[pos_salmonella,]
boxplot(data_mat_salmonella,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of Salmonella Data")
P_values <- vector() # Empty vector
for (iter in 1: dim(data_mat_salmonella)[1]){ # go row by row
t_stats <-t.test(data_mat_salmonella[iter,c(1,2,3,4)],data_mat_salmonella[iter,c(9,10,11,12)],var.equal = TRUE) # compute t statistic for each row of  high v low concentration
P_values[iter]<- t_stats$p.value # Store the P-Values
}
hist(P_values) # Plot histogram of P-Values
sum(P_values<0.05)/length(P_values)
sum(P_values<0.05)
sum(P_values<0.05)/length(P_values)
source('C:/Users/adi44/Desktop/ATM/Spring 2018/STAT646/HW3/store_object.R')
z<-sin(c(1:1000))
plot(z)
abline(z)
curve(z)
curve(z)
x <- seq(0,pi,length.out=100)
y <- sin(x)
plot(x,y,type="l")
x <- seq(0,2*pi,length.out=100)
y <- sin(x)
plot(x,y,type="l")
polygon(c(min(x),x),c(min(y),y), density = 5,col="chocolate1")
## Use seqinr to obtain the Genbank sequence for PSEN1.
library(seqinr)
choosebank("genbank")
PSEN1 <- query(listname = "PSEN1", query="SP=homo sapiens AND K=PSEN1")
psen1_seqs <- getSequence(PSEN1)
psen1_names <- getName(PSEN1)
length(psen1_seqs)
print(psen1_names)
print(unlist(lapply(psen1_seqs,length)))
write.fasta(psen1_seqs[1], psen1_names[1], file.out = "MyPSEN1.fasta")
sum(table(psen1_seqs[[3]])[2:3]) / length(psen1_seqs[[3]])*100
library(Biostrings)
seq_1 <- "GTAG"
seq_2 <- "GAG"
score_mat <- nucleotideSubstitutionMatrix(match = 1, mismatch = -1, baseOnly = TRUE)
gap_open <- -2
gap_extend <- -2
seq_1 <- "ASEDLTI"
seq_2 <- "AEEDFGI"
data(PAM30)
score_mat <- "PAM30"
gap_open <- 0
gap_extend <- -2
global_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "global", scoreOnly = FALSE)
local_alignment <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = score_mat,
gapOpening = gap_open, gapExtension = gap_extend, type = "local", scoreOnly = FALSE)
global_alignment
local_alignment
gen_random_seqs <- function(sq, B) {
## Break input sequence into vector of characters.
sq <- strsplit(sq, "")[[1]]
n <- length(sq)
## Compute sample proportions of each observed letter.
sq_tbl <- table(sq)
sq_letters <- names(sq_tbl)
n_letters <- length(sq_letters)
pp <- numeric()
for(i in 1:length(sq_letters))
pp[i] <- sq_tbl[i] / n
## Generate B random sequences by sampling with replacement using a multinomial model.
sqs <- numeric(B)
for(i in 1:B)
sqs[i] <- paste(sample(sq_letters, n, rep = TRUE, prob = pp), collapse = "")
return(sqs)
}
## Function for computing a p-value for the alignment of two sequences. The sequence in
## the first argument should be shorter than or equal in length to that in the second
## argument.
align_p_val <- function(seq_1, seq_2, scoringMat, gapOpen, gapExtend, alignType, B) {
## Compute alignment score for original pair of sequences.
tt_0 <- pairwiseAlignment(seq_1, seq_2, substitutionMatrix = scoringMat,
gapOpening = gapOpen, gapExtension = gapExtend, type = "local", scoreOnly = TRUE)
## Generate B random versions of first sequence.
random_seqs <- gen_random_seqs(seq_1, B)
## For each random sequence, re-run the alignment and store the resulting score.
tt_B <- numeric(B)
for(i in 1:B)
tt_B[i] <- pairwiseAlignment(random_seqs[i], seq_2, substitutionMatrix = scoringMat,
gapOpening = gapOpen, gapExtension = gapExtend, type = alignType, scoreOnly = TRUE)
## Compute a p-value as the proportion of randomization-based alignment scores that are
## equal to or greater than our original observed score.
p_val <- mean(tt_B >= tt_0)
return(list("tt_0" = tt_0, "tt_B" = tt_B, "p_val" = p_val))
}
set.seed(101)
out <- align_p_val(seq_1, seq_2, score_mat, gap_open, gap_extend, "local", 1000)
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta >=0 ]), delta)
polygon(c(dd$x[ii], dd$x[ii:pos_x], dd$x[pos_x]), c(0, dd$y[ii:pos_x], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta >=0 ]), delta)
polygon(c(dd$x[ii], dd$x[ii:pos_x], dd$x[pos_x]), c(0, dd$y[ii:pos_x], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x <=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta <=0 ]), delta)
polygon(c(dd$x[ii], dd$x[ii:pos_x], dd$x[pos_x]), c(0, dd$y[ii:pos_x], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
pos_x <- max(which(dd$x >=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta <=0 ]), delta)
polygon(c(dd$x[ii], dd$x[ii:pos_x], dd$x[pos_x]), c(0, dd$y[ii:pos_x], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
#pos_x <- max(which(dd$x >=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta <=0 ]), delta)
polygon(c(dd$x[ii], dd$x[ii:m], dd$x[m]), c(0, dd$y[ii:m], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta >= 0]), delta)
polygon(c(dd$x[ii], dd$x[ii:m], dd$x[m]), c(0, dd$y[ii:m], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
#pos_x <- max(which(dd$x >=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta >= 0]), delta)
polygon(c(dd$x[ii], dd$x[ii:m], dd$x[m]), c(0, dd$y[ii:m], 0), col = "red")
dd <- density(out$tt_B)
plot(dd, main = "Randomization-based scores")
#pos_x <- max(which(dd$x >=19))
m <- length(dd$x)
delta <- dd$x - 19
ii <- match(min(delta[delta >= 0]), delta)
polygon(c(dd$x[ii], dd$x[ii:m], dd$x[m]), c(0, dd$y[ii:m], 0), col = "red")
plot(dd, main = "Randomization-based scores")
polygon(c(dd$x[ii], dd$x[ii:m], dd$x[m]), c(0, dd$y[ii:m], 0), col = "red")
data_mat<-as.matrix(data_csv_filtered[,8:19])
pos_qc <- which(data_csv_filtered[,7]==1)
data_mat_qc<-data_mat[pos_qc,]
boxplot(data_mat_qc,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of Filtered Data")
#boxplot.matrix(data_mat)
data_mat<-as.matrix(data_csv_filtered[,8:19])
pos_qc <- which(data_csv_filtered[,7]==1)
data_mat_qc<-data_mat[pos_qc,]
boxplot(data_mat_qc,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of Filtered Data")
#boxplot.matrix(data_mat)
data_mat<-as.matrix(data_csv_filtered[,8:19])
pos_qc <- which(data_csv_filtered[,7]==1)
data_mat_qc<-data_mat[pos_qc,]
boxplot(data_mat_qc,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of QC  Data")
#boxplot.matrix(data_mat)
boxplot(data_mat_qc,las=2,at =c(1,2,3,4, 6,7,8,9, 11,12,13,14),
col=c('red','sienna','palevioletred1','royalblue2','red','sienna','palevioletred1',
'royalblue2','red','sienna','palevioletred1','royalblue2'),main="Boxplot of QC  Data")
source('C:/Users/adi44/Desktop/ATM/Spring 2018/STAT646/HW4/Lahiri Aditya.R')
source('C:/Users/adi44/Desktop/ATM/Spring 2018/STAT646/HW4/Lahiri Aditya.R')
source('C:/Users/adi44/Desktop/ATM/Spring 2018/STAT646/HW4/Lahiri Aditya.R')
source('C:/Users/adi44/Desktop/ATM/Spring 2018/STAT646/HW4/Lahiri Aditya.R')
sample(1:(50-1),1)
source('C:/Users/adi44/Desktop/ATM/Spring2018/STAT646/HW4/Lahiri Aditya.R')
nc
frg
nchar(frg)
rbinom(r,1,prob=a)
rbinom(r,1,prob=a)
rbinom(r,1,prob=a)
source('C:/Users/adi44/Desktop/ATM/Spring2018/STAT646/HW4/Lahiri Aditya.R')
Read_Table
setwd("C:/Users/adi44/Desktop/CodeHouse/Graph-Network/WRKY_Transcription_Factor/DATASET")
